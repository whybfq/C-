/*********************************************************************************
  *@copyright (C)  Sep 2018  San
  *@bug :
  *@brief:   重载全局的new和delete,只是改变了原有的内存分配方法，记住这一点是很重要的。
  * 编译器将用重载的 new 代替默认的版本去分配内存，然后为那个内存调用构造函数。所以，虽然当编译器看到 new 时，编译器分配内存并调用构造函数，但是当重载 new 时，可以改变的只是内存分配部分（ delete 也有相似的限制。）

  *@CMAKE_CXX_STANDARD 17
  *@IDE: Clion 2018.3
  *@OS:  macOS High Sierra 10.13.6
  *
  *@function_lists:
  *  1.

  *@history:
     1.Date:
       Author:
       Modification:
**********************************************************************************/
#include "Tree.h"
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>
#include <cstring>

using namespace std;

void *operator new(size_t sz) {
    cout << "operator new functon: " << sz << " Bytes "<< endl;
    void *m = malloc(sz);
    if(!m)puts("out of memory");
    return m;
}

void operator delete(void* m) {
    puts("operator delete function ");
    free(m);
}

class S {
public:
    S() { puts("S::S() "); }
    ~S() { puts("S::~S() "); }
private:
    int i;
};
int main( )
{
    puts(" creating & destroying an int ");
    int *p = new int(47);
    delete p;
    puts(" crating & destroying an s ");
    S* s = new S;
    delete s;
    puts(" creating & destroying S[3] ");
    S* sa = new S[3];
    delete []sa;
}
