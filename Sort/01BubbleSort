//Reference : https://mp.weixin.qq.com/s/Vq1dpZm2Mx_qeDofOuvObw

/*********************************************************************************
  *@copyright (C)  2018 san All Rights Reserved
  *@brief: some common algorighms including BubbleSort
  *@bug :
  *@author: sanner
  *
  *@CMAKE_CXX_STANDARD 17
  *@IDE: Clion 2018.2
  *@OS:  macOS 10.14
  *
  *@function_lists:
  *  1.  void Swap(int A[] , int i, int j   -- exchange A[i] and A[j],dtype=int
     2.  void swap1(T&a,T&b)                -- exchange a and b

  *@history:
     1.@date: 2018/06/02
       @author: sanner
       @modification: Original
     2.@date:  2018/06/16
       @author: sanner
       @modification: Separate large files into small ones
     3.@date:  2018/10/17
       @author: sanner
       @modification: Optimizing the bubble sort:
         by stopping the algorithm if inner loop didn’t cause any swap. add the variable swapped
**********************************************************************************/
#include <iostream>

using std:: cin ;
using std:: cout;
using std:: endl;
using std:: swap;

void BubbleSort(int *A, int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = i + 1; j < n ; ++j) {
            if(A[i] > A[j]){
                swap(A[i], A[j]);
            }
        }
    }
}

void BubbleSort2(int a[], int size)  //using a flag bSwaped to determine if there is a redundant exchange in a loop
{
	 bool bSwaped = true;
 	 for (int i = 0; i < size -1; i++)
	 {
		   bSwaped = false;  // 每次先重置为false
		   for (int j = size - 1; j > i ; j--)
		   {
			     if (a[j-1] > a[j])
			     {
				        swap(a[j-1],a[j]);
				        bSwaped = true;
			     }
		   }
		   if (!bSwaped) break;  // // 如果上一次扫描没有发生交换，则说明数组已经全部有序，退出循环
	  }
}

/*
 * 在第一步优化的基础上发进一步思考：如果R[0..i]已是有序区间，上次的扫描区间是R[i..n]，记上次扫描时最后
 * 一次执行交换的位置为lastSwapPos，则lastSwapPos在i与n之间，不难发现R[i..lastSwapPos]区间也是有序的，
 * 否则这个区间也会发生交换；所以下次扫描区间就可以由R[i..n] 缩减到[lastSwapPos..n]。
*/
void BubbleSort3(int *A, int n) {
    int lastSwapPos = 0, lastSwapPosTemp = 0;
    for (int i = 0 ; i < n - 1; ++i) {
        lastSwapPos = lastSwapPosTemp;
        for (int j = n -1; j > lastSwapPos ; --j) {
            if(A[j - 1] > A[j]){
                swap(A[j - 1], A[j]);
                lastSwapPosTemp = j;
            }
        }
        if(lastSwapPos == lastSwapPosTemp) break;
    }
}

void Swap(int A[] , int i, int j){
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}

template <typename T>
void swap1(T& a, T& b){  // attention local variable: need to use &
    T c(a);
    a=b;
    b=c;
}


/******************************************************************************************************/
// 数据结构 ---------- 数组

// 最差时间复杂度 ---- O(n^2)

// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)

// 平均时间复杂度 ---- O(n^2)

// 所需辅助空间 ------ O(1)

// 稳定性 ------------ 稳定( A[i]>A[i+1] )
void BubbleSort(int *A,int n){
    for(int j = 0;j < n; ++j){  // 每次最大元素就像气泡一样"浮"到数组的最后
        bool swapped = false;    // flag
        for(int i = 0; i < n-j-1; ++i){  // 依次比较相邻的两个元素,使较大的那个向后移
            if(A[i] > A[i+1]){  // 如果条件改成A[i] >= A[i + 1],则变为不稳定的排序算法
                Swap(A,i,i+1);
                swapped = true;
            }
        }
        if(!swapped) break;  // if no elements were swapped in inner loop, then break
    }
}

// More generally, it can happen that more than one element is placed in their final position on a single pass. 
// In particular, after every pass, all elements after the last swap are sorted, and do not need to be checked again.
// This allows us to skip over a lot of the elements, resulting in about a worst case 50% improvement in comparison
// count (though no improvement in swap counts), 
// and adds very little complexity because the new code subsumes the "swapped" variable
void BubbleSort2(int A[], int n) {
    while( n > 1) {
        int newn = 0;
        for (int i = 1; i < n; ++i) {
            if(A[i - 1] > A[i]){
                swap(A[i - 1], A[i]);
                newn = i;
            }
        }
        n = newn;
    }
}

// 冒泡排序改进，鸡尾酒排序，（定向冒泡排序）
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定
void CocktailSort(int A[],int n){
    int left=0, right=n-1;
    while(left <= right){
        for(int i = left; i < right; ++i){
            if(A[i] > A[i+1]) Swap(A, i, i+1 );
        }
        --right;
        for(int i = right; i > left ; --i){
            if(A[i-1] > A[i]) Swap(A,i-1,i);
        }
        ++left;
    }
}

/******************************************************************************************************/
// Selecting Sort

// 数据结构 ---------- 数组

// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- O(n^2)
// 平均时间复杂度 ---- O(n^2)

// 选择排序的交换操作介于 0 和 (n - 1） 次之间。
// 选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。
// 所需辅助空间 ------ O(1)
// 总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2。

// 稳定性 ------------ 不稳定
void SelectionSort(int A[],int n){
    for(int i = 0; i < n-1; ++i){
        int min = i;
        for(int j = i+1; j < n; ++j){
            if(A[j] < A[min]){
                min = j;
            }
        }
        if(min != i){
            Swap(A,min,i);
        }
    }
}

void SelectionSort1(int *A,int n){
    for(int i = 0 ; i < n-1;++i){   //n-1 selection
        for(int j=i+1;j<n;++j)
            if(A[j] < A[i])
                swap1( A[j],A[i] );
    }
}

//Reference : https://blog.csdn.net/qq_26768741/article/details/53313093
template<typename T>
void SelectionSort2(T *A, int n){
    assert(A);
    int left = 0,right = n-1;
    while(left < right){
        int min = left, max = right;
        for(int i = left; i < right; ++i){
            if(A[i] < A[min])
                min = i;
            if(A[i] > A[max])
                max = i;
        }
        //考虑修正的情况，最大值在最小位置，最小值在最大位置。
        swap(A[max], A[right]);
        if(min == right){
            min = max;
        }
        swap(A[min],A[left]);
        ++left;
        --right;
    }
}

/******************************************************************************************************/

int main(){
    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };   // 从小到大定向冒泡排序
    int n = sizeof(A) / sizeof(int);  // n = sizeof(A) / sizeof(A[0])
//    BubbleSort(A,n);
//    CocktailSort(A,n);

    cout << "the resulr of Sort: " << endl;
    for(int i=0;i<n;++i){
        cout << A[i] << " " << endl;
    }
}
