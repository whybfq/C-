#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <boost/assign.hpp>
#include <boost/core/ignore_unused.hpp>


using namespace std;
using namespace boost;

/*********************************************************************************
  *FileName:  Nine_cards  (This program is similiar to the first program in DFS which is called The_whole_arrangement
  *Author:  W
  *Version:  **
  *Date:  2018-06-01
  *Description:  编号1～9的扑克牌◻︎，放入9个盒子中，使得☐☐☐ + ☐☐☐ = ☐☐☐
  *              主要使用dfs思想。
                 假设有9个盒子，依次往其中放入编号1～9的扑克牌，则放到n+1时，
                 输出盒子中的扑克牌编号就是一种可能排列。
  *Others:  数组a表示小盒子
  *Function List:  
     1. void dfs(int step) 
        step          --表示当前所在的盒子，
        a[ste[]=i     --将第i号扑克牌放入到第step个盒子中 
        book数组       --用来标记扑克牌是否还在手上。

  *History:  //修改历史记录列表，每条修改记录应包含修改日期、修改者及修改内容简介
     1.Date:
       Author:
       Modification:
     2.…………
**********************************************************************************/

int a[10]={0},book[10]={0},total=0;
void dfs(int step){
    int i;
    if(step == 10){
        if(a[1]*100 + a[2]*10 + a[3] + a[4]*100 + a[5]*10 + a[6] == a[7]*100 + a[8]*10 + a[9]){
            total++;
            int m=0;
            //cout<<a[1]<<a[2]<<a[3]<<a[4]<<a[5]<<a[6]<<a[7]<<a[8]<<a[9]<<endl;
            while(m<9)
                cout<<a[++m];
            cout<<endl;
        }
        return;
    }

    for(i=1; i <= 9; ++i){
        if(book[i] == 0){
            a[step] = i;
            book[i] = 1;

            dfs(step + 1);
            book[i] = 0;
        }
    }
    return;
}

int main(){
    dfs(1);
    cout<<"total="<<total/2<<endl;
    getchar();
}
